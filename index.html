<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <title>p5.js Responsive Example</title>
  <style>
    img {
      display: block;
      position: absolute;
    }
    .emotion-label {
      text-align: center;
      color: black;
      font-size: 10px;
      position: absolute;
    }
    #download-btn {
      display: none;
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 10px 20px;
      background-color: white;
      color: black;
      border: 2px solid black;
      cursor: pointer;
    }
    #landing-page {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      font-size: 24px;
      text-align: center;
    }
    #ok-btn {
      padding: 10px 20px;
      margin-top: 20px;
      background-color: black;
      color: white;
      cursor: pointer;
      border: none;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <div id="landing-page">
    <div id="random-text"></div>
    <button id="ok-btn">OK</button>
  </div>

  <button id="download-btn">画像をダウンロード</button>
  
  <script>
    let backgroundImages = [];
    let motifImages = [];
    let emotionsA_ja = ['喜び', '信頼', '恐れ', '驚き', '悲しみ', '嫌悪', '怒り', '期待＜予期＞'];
    let emotionsB_ja = ['恍惚', '敬愛', '恐怖', '驚嘆', '悲嘆', '強い嫌悪', '激怒', '警戒'];
    let emotionsC_ja = ['平穏', '容認', '不安', '放心', '哀愁', 'うんざり', '苛立ち', '関心'];

    const emotionTranslations = {
      '喜び': 'Joy', '信頼': 'Trust', '恐れ': 'Fear', '驚き': 'Surprise', '悲しみ': 'Sadness',
      '嫌悪': 'Disgust', '怒り': 'Anger', '期待＜予期＞': 'Anticipation', '恍惚': 'Ecstasy',
      '敬愛': 'Admiration', '恐怖': 'Terror', '驚嘆': 'Amazement', '悲嘆': 'Grief', '強い嫌悪': 'Loathing',
      '激怒': 'Rage', '警戒': 'Vigilance', '平穏': 'Serenity', '容認': 'Acceptance', '不安': 'Apprehension',
      '放心': 'Distraction', '哀愁': 'Pensiveness', 'うんざり': 'Boredom', '苛立ち': 'Annoyance', '関心': 'Interest'
    };

    let emotionsA = emotionsA_ja;
    let emotionsB = emotionsB_ja;
    let emotionsC = emotionsC_ja;

    let emotionSize = 100;
    let backgroundChoice = 0;

    let selectedEmotions = {};
    let buttons = {};
    let labels = {};
    let checkButton;
    let isResultDisplayed = false;

    let downloadBtn; 
    let labelElements = []; 
    let nextPageBtn, prevPageBtn;
    let countDisplay;
    let selectedCount = 0;
    let savedImgWidth, savedImgHeight;

    const positiveEmotions = ['喜び', '信頼', '驚き', '期待＜予期＞', '恍惚', '敬愛', '驚嘆', '平穏', '容認', '関心'];
    const negativeEmotions = ['恐れ', '悲しみ', '嫌悪', '怒り', '恐怖', '悲嘆', '強い嫌悪', '激怒', '警戒', '不安', '放心', '哀愁', 'うんざり', '苛立ち'];

    const emotionColors = {
      '喜び': '#B50000',
      '信頼': '#E58351',
      '恐れ': '#FFD036',
      '驚き': '#36C238',
      '悲しみ': '#008704',
      '嫌悪': '#5D94A6',
      '怒り': '#00699D',
      '期待＜予期＞': '#FF7CC0',
      '恍惚': '#7F0000',
      '敬愛': '#B2653E',
      '恐怖': '#CCA32A',
      '驚嘆': '#003A00',
      '悲嘆': '#00496B',
      '強い嫌悪': '#406672',
      '激怒': '#278E27',
      '警戒': '#CC6399',
      '平穏': '#E50000',
      '容認': '#FF7F3F',
      '不安': '#FF8F00',
      '放心': '#00BA03',
      '哀愁': '#008ED1',
      'うんざり': '#7FCBE2',
      '苛立ち': '#B2E4B2',
      '関心': '#FF7CC0'
    };

    const randomTexts = [
      '今の気分は？'
    ];

    function showRandomText() {
      const randomIndex = Math.floor(Math.random() * randomTexts.length);
      document.getElementById('random-text').innerText = randomTexts[randomIndex];
    }

    document.getElementById('ok-btn').addEventListener('click', () => {
      document.getElementById('landing-page').style.display = 'none';
      startEmotionSelection();
    });
    
    function preload() {
      backgroundImages[0] = loadImage('https://mooo0ooo.github.io/diary/background1.png');
      backgroundImages[1] = loadImage('https://mooo0ooo.github.io/diary/background2.png');
      backgroundImages[2] = loadImage('https://mooo0ooo.github.io/diary/background3.png');
      backgroundImages[3] = loadImage('https://mooo0ooo.github.io/diary/background4.png');

      motifImages['喜び'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/fireworks-removebg-preview.png');
      motifImages['信頼'] = loadImage('https://mooo0ooo.github.io/diary/sun-removebg-preview.png');
      motifImages['恐れ'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/moon-removebg-preview.png');
      motifImages['驚き'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/thunder.PNG');
      motifImages['悲しみ'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/shooting_star-removebg-preview.png');
      motifImages['嫌悪'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/rain.PNG');
      motifImages['怒り'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/star-removebg-preview.png');
      motifImages['期待＜予期＞'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/balloon.PNG');
      motifImages['恍惚'] = loadImage('https://mooo0ooo.github.io/diary/rose.PNG');
      motifImages['敬愛'] = loadImage('https://mooo0ooo.github.io/diary/tulip.PNG');
      motifImages['恐怖'] = loadImage('https://mooo0ooo.github.io/diary/yellowFlower.PNG');
      motifImages['驚嘆'] = loadImage('https://mooo0ooo.github.io/diary/clover.PNG');
      motifImages['悲嘆'] = loadImage('https://mooo0ooo.github.io/diary/futaba.PNG');
      motifImages['強い嫌悪'] = loadImage('https://mooo0ooo.github.io/diary/mizuiroFlower.PNG');
      motifImages['激怒'] = loadImage('https://mooo0ooo.github.io/diary/blueFlower.PNG');
      motifImages['警戒'] = loadImage('https://mooo0ooo.github.io/diary/cherryBlossom.PNG');
      motifImages['平穏'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/apple.PNG');
      motifImages['容認'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/carrot.PNG');
      motifImages['不安'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/egg.PNG');
      motifImages['放心'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/avocado.PNG');
      motifImages['哀愁'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/broccoli.PNG');
      motifImages['うんざり'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/turnip.PNG');
      motifImages['苛立ち'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/fork.PNG');
      motifImages['関心'] = loadImage('https://raw.githubusercontent.com/mooo0ooo/diary/main/glove.PNG');
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      showRandomText();  
    
      downloadBtn = select('#download-btn');
      downloadBtn.mousePressed(downloadCanvas);
    
      nextPageBtn = createButton('次のページ');
      nextPageBtn.position(width - 100, height - 50);
      nextPageBtn.hide();
      nextPageBtn.mousePressed(showSecondPage);
    
      prevPageBtn = createButton('前のページ');
      prevPageBtn.position(20, windowHeight - 50);
      prevPageBtn.hide();
      prevPageBtn.mousePressed(() => {
        clear();
        resizeCanvas(windowWidth, windowHeight);
        labelElements.forEach(label => label.hide()); 
        labelElements = []; 
        displayResult(); 
      });

      effectLayer = createGraphics(windowWidth, windowHeight); // エフェクト用レイヤー
    }

    function draw() {
      if (isResultDisplayed) return;
      
      clear();
      drawEmotionGrid(emotionsA, 0);
      drawEmotionGrid(emotionsB, 1);
      drawEmotionGrid(emotionsC, 2);
    
      if (checkButton) {
        const centerX = windowWidth / 2;
        const countWidth = 40;
        const checkButtonWidth = 100;
        const offset = (checkButtonWidth + countWidth) / 2;
    
        countDisplay.position(centerX - offset, windowHeight - 100);
        checkButton.position(centerX - offset + countWidth + 10, windowHeight - 100);
      }

      image(effectLayer, 0, 0); // エフェクトレイヤーを描画
    }
  
   function startEmotionSelection() {
      createEmotionButtons();
      countDisplay = createDiv(`${selectedCount}/25`);
      countDisplay.style('font-size', '14px');
      
      checkButton = createButton('Check');
      checkButton.mousePressed(displayResult);
    }


    function drawEmotionGrid(emotions, row) {
      let colCount = getColCount();
      let xOffset = 20;
      let yOffset = 120;
      let totalRowWidth = (colCount * emotionSize) + ((colCount - 1) * xOffset);
      let startX = (windowWidth - totalRowWidth) / 2;

      for (let i = 0; i < emotions.length; i++) {
        let x = startX + (i % colCount) * (emotionSize + xOffset);
        let y = row * (emotionSize + yOffset) + yOffset;

        buttons[emotions[i]].position(x, y);
        labels[emotions[i]].position(x + emotionSize / 2 - 20, y + emotionSize + 5);
      }
    }

    function getColCount() {
      if (windowWidth > 1200) return 8;
      if (windowWidth > 800) return 6;
      return 4;
    }

    function createEmotionButtons() {
      const emotionList = [
        '喜び', '信頼', '恐れ', '驚き', '悲しみ', '嫌悪', '怒り', '期待＜予期＞', '恍惚', 
        '敬愛', '恐怖', '驚嘆', '悲嘆', '強い嫌悪', '激怒', '警戒', '平穏', '容認', 
        '不安', '放心', '哀愁', 'うんざり', '苛立ち', '関心'
      ];
      
      emotionList.forEach(emotion => {
        buttons[emotion] = createImg(motifImages[emotion].src, emotion).size(emotionSize, emotionSize).mousePressed(() => handleEmotionButton(emotion));
        labels[emotion] = createDiv(emotion).addClass('emotion-label');
      });
    }

    function showEffect(emotion) {
      let color = emotionColors[emotion];
      let shapes = ['star', 'hexagon', 'diamond', 'circle'];
      for (let i = 0; i < 100; i++) {
        let x = random(width);
        let y = random(height);
        let size = random(2, 8);
        let shape = random(shapes);
        let isFilled = random() < 0.5;

        drawShape(effectLayer, x, y, shape, size, color, isFilled);

        setTimeout(() => {
          effectLayer.noFill();
          effectLayer.stroke(255);
          drawShape(effectLayer, x, y, shape, size, color, isFilled);
        }, 2000);
      }
    }

    function drawShape(layer, x, y, shape, size, color, isFilled) {
      if (isFilled) {
        layer.fill(color);
      } else {
        layer.noFill();
      }
      layer.stroke(color);
      layer.strokeWeight(0.5);

      switch (shape) {
        case 'star':
          layer.beginShape();
          for (let i = 0; i < 10; i++) {
            let angle = PI / 5 * i;
            let radius = i % 2 === 0 ? size : size / 2;
            let posX = x + cos(angle) * radius;
            let posY = y + sin(angle) * radius;
            layer.vertex(posX, posY);
          }
          layer.endShape(CLOSE);
          break;

        case 'hexagon':
          layer.beginShape();
          for (let i = 0; i < 6; i++) {
            let angle = PI / 3 * i;
            layer.vertex(x + cos(angle) * size, y + sin(angle) * size);
          }
          layer.endShape(CLOSE);
          break;

        case 'diamond':
          layer.beginShape();
          layer.vertex(x, y - size);
          layer.vertex(x + size / 2, y);
          layer.vertex(x, y + size);
          layer.vertex(x - size / 2, y);
          layer.endShape(CLOSE);
          break;

        case 'circle':
          layer.ellipse(x, y, size * 2);
          break;
      }
    }

    function handleEmotionButton(emotionLabel) {
      if (selectedCount >= 25) return;

      let emotion = emotionLabel;
      if (!selectedEmotions[emotion]) selectedEmotions[emotion] = 0;
      selectedEmotions[emotion]++;
      selectedCount++;

      countDisplay.html(`${selectedCount}/25`);
      showEffect(emotion);
    }

    function displayResult() {
      clear();
      countDisplay.hide();
      checkButton.hide();
      for (let key in buttons) {
        buttons[key].hide();
        labels[key].hide();
      }
      labelElements.forEach(label => label.remove());
      labelElements = []; 

      let positiveCount = 0;
      let negativeCount = 0;

      for (let emotion in selectedEmotions) {
        if (positiveEmotions.includes(emotion)) {
          positiveCount += selectedEmotions[emotion];
        } else if (negativeEmotions.includes(emotion)) {
          negativeCount += selectedEmotions[emotion];
        }
      }

      backgroundChoice = positiveCount > negativeCount ? (Math.random() < 0.5 ? 0 : 3) : (Math.random() < 0.5 ? 1 : 2);

      let img = backgroundImages[backgroundChoice];
      let imgAspect = img.width / img.height;
      let canvasAspect = width / height;
      let imgWidth, imgHeight;

      if (imgAspect > canvasAspect) {
        imgWidth = width;
        imgHeight = width / imgAspect;
      } else {
        imgHeight = height;
        imgWidth = height * imgAspect;
      }

      savedImgWidth = imgWidth;
      savedImgHeight = imgHeight;

      image(img, (width - imgWidth) / 2, (height - imgHeight) / 2, imgWidth, imgHeight);

      let mostSelectedEmotion = getMostSelectedEmotion();
      let motif = motifImages[mostSelectedEmotion];
      if (motif) {
        image(motif, width / 2 - motif.width / 2, height / 2 - motif.height / 2);
      }

      nextPageBtn.show();
      prevPageBtn.hide();
      downloadBtn.show();
      isResultDisplayed = true; // 結果が表示されたことを記録
    }

    function showSecondPage() {
      resizeCanvas(savedImgWidth, savedImgHeight);

      let offsetX = (windowWidth - savedImgWidth) / 2;
      let offsetY = (windowHeight - savedImgHeight) / 2;

      clear();
      background(255);

      translate(offsetX, offsetY);

      let selectedEmotionsList = Object.keys(selectedEmotions);
      let gridSize = 5;
      let imgSize = savedImgWidth / gridSize - 10;
      let padding = 10;

      let totalGridWidth = gridSize * (imgSize + padding) - padding;
      let startX = (savedImgWidth - totalGridWidth) / 2;
      let startY = (savedImgHeight - totalGridWidth) / 2;

      let posX, posY;
      let displayed = 0;

      for (let emotion of selectedEmotionsList) {
        let motifImage = motifImages[emotion];
        let displayCount = selectedEmotions[emotion];

        for (let i = 0; i < displayCount; i++) {
          if (displayed >= 25) break;

          posX = startX + (displayed % gridSize) * (imgSize + padding);
          posY = startY + Math.floor(displayed / gridSize) * (imgSize + padding);

          if (motifImage) {
            image(motifImage, posX, posY, imgSize, imgSize);

            let label = createDiv(emotionTranslations[emotion]);
            label.position(offsetX + posX + imgSize / 2 - 10, offsetY + posY + imgSize + 5);
            label.style('font-size', '10px');
            label.style('text-align', 'center');
            labelElements.push(label);
          }
          displayed++;
        }
        if (displayed >= 25) break;
      }

      prevPageBtn.show();
      nextPageBtn.hide();
      downloadBtn.show();
    }

    function downloadCanvas() {
      labelElements.forEach(label => {
        const x = label.position().x;
        const y = label.position().y;
        const textContent = label.html();
        fill(0);
        textSize(10);
        textAlign(CENTER);
        text(textContent, x, y);
      });

      saveCanvas('emotion_canvas', 'png');
    }

    function getMostSelectedEmotion() {
      let maxCount = -1;
      let selectedEmotion = '';
      for (let emotion in selectedEmotions) {
        if (selectedEmotions[emotion] > maxCount) {
          maxCount = selectedEmotions[emotion];
          selectedEmotion = emotion;
        }
      }
      return selectedEmotion;
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      clear();
      drawEmotionGrid(emotionsA, 0);
      drawEmotionGrid(emotionsB, 1);
      drawEmotionGrid(emotionsC, 2);
      nextPageBtn.position(width - 100, height - 50);
      prevPageBtn.position(20, height - 50);
    }
  </script>
</body>
</html>
    
